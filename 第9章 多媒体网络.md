# 第9章 多媒体网络

## 9.1多媒体网络应用

1.在视频中由两种类型的冗余，它们都可以用来进行视频压缩。<font color = #FF0000>空间冗余</font>是给定图像的内部冗余。<font color = #FF0000>时域冗余</font>反映一副图像和后续图像的重复程度。

2.<font color = #FF0000>脉冲编码调制（Pulse Code Modulation, PCM）</font>将模拟音频转换为数字信号：

* 模拟音频信号首先以某种固定速率采样。每个采样值是一个任意的实数。

* 然后每个采样值被“四舍五入”为有限个数值中的一个。这种操作被称为<font color = #FF0000>量化</font>。这些有限个数值通常是2的幂。

* 每个量化值由固定数量的比特表示。通过音频扬声器播放，这个数字信号则能够转换回来（也就是解码），形成一个模拟信号。然而，解码后的模拟信号仅是初始信号的近似，并且声音质量也许有明显的下降。通过增加采样速率和量化值的数量，解码信号能够更好地接近初始的模拟信号。因此，在解码信号的质量和比特率与数字信号存储空间存在一种折中。

3.一种接近CD质量立体声音乐的流行压缩技术是<font color = #FF0000>MPEG 1第3层</font>，更通常的叫法是<font color = #FF0000>MP3</font>。MP3编码器通常能够压缩为许多不同的速率；128kbps是最常用的编码速率，并且能够产生非常小的声音失真。一种相关的标准是<font color = #FF0000>高级音频编码（Advanced Audio Coding, AAC）</font>。

4.多媒体应用可以分为三大类：<font color = #FF0000>流式存储音频/视频；会话式IP语音/视频；流式实况音频/视频</font>。

​       流式存储视频具有三个关键的不同特色：

* 流。在流式存储视频应用中，客户开始从服务器接收文件几秒之后，通常就开始播放视频。这意味着当客户正在从视频的一个位置开始播放时，与此同时正在从服务器接收该视频的后续部分。这种技术被称为<font color = #FF0000>流</font>，它避免了在开始播放之前必须下载整个视频。

* 相互作用。因为媒体是预先录制的，用户可以对多媒体内容进行暂停、重新配置前进、重新配置倒退、快进等操作。从一个客户提出这种请求到该动作在客户端表现出来，可接收的响应时间应该小于几秒。

* 连续播放。一旦视频开始播放，它应该根据初始记录的时序进行。因此，为了在客户端播放，必须从服务器中及时接收数据；否则，用户经历视频帧停滞或帧跳过。

在因特网上的实时会话式语音通常称为<font color = #FF0000>因特网电话</font>。也常被称为<font color = #FF0000>IP语音（Voice-over-IP, VoIP）</font>。

流式实况音频和视频类似于传统的电台广播和电视，只是它通过因特网来传输而已。



## 9.2流式存储视频

1.流式视频系统可分为三种类型：<font color = #FF0000>UDP流、HTTP流和适应性HTTP流</font>。

2.当视频开始到达客户时，客户不必立即开始播放，反而能够在应用程序缓存中建立该视频的储备。一旦客户建立起几秒“已缓存但尚未播放”的视频储备，客户就可以开始视频播放了。这种<font color = #FF0000>客户缓存</font>具有两种重要的优点。第一，客户缓存能够吸收服务器到客户时延中的波动。第二，如果服务器到客户带宽暂时低于视频消耗速率，用户能够继续享受连续的播放，只要客户应用缓存仍没有完全排尽。

3.使用<font color = #FF0000>UDP流</font>，服务器通过UDP以一种稳定的速率记录下视频块，用于哭护的视频消耗速率向匹配的速率传输视频。在将视频块传递给UDP之前，服务器将视频块封装在运输分组中，该运输分组是专门为传输音频和视频而设计的，使用了<font color = #FF0000>实时传输协议（Real-Time Transport Protocal, RTP）</font>或某种类似的方案。UDP流的另一种不同的性质是，除了服务器到客户的视频流外，两者间还并行地维护一个单独的控制连接，通过该连接，客户可发送有关会话状态变化的命令。

​       UDP流有三个重大不足。首先，由于服务器和控制之间的可用带宽无法预测并且是变化的，恒定速率UDP流不能够提供连续的播放。第二个缺点是它要求如RTSP服务器这样的媒体控制服务器，以对每个进行中的客户会话处理客户到服务器的交互请求和跟踪客户状态。这增加了部署大规模的按需视频系统的总体成本和复杂性。第三个缺点是许多防火前配置为阻塞UDP流量，防止这些防火墙后面的用户接收UDP视频。

4.在<font color = #FF0000>HTTP流</font>中，视频直接作为具有一个特定URL的普通文件存储在HTTP服务器上。当用户要看视频时，客户和服务器之间建立一个TCP连接，并且发送一个对该URL的HTTP GET请求。服务器则尽可能快地在HTTP响应报文中发送该视频文件。在客户端上，字节收集在一个客户应用缓存中。一旦在缓存中字节数量超过了预先设定的阈值，该客户应用程序开始播放，具体而言，它周期性地从客户应用缓存中抓取视频帧，对帧解压缩并在用户屏幕上显示它们。

​       在TCP上使用HTTP也使得视频穿越防火墙和NAT更为容易。HTTP流消除了因需要媒体服务器带来的不便，减少了在因特网上大规模部署的成本。

5.对于流式存储视频，客户能够尝试以高于消耗速率的速率下载视频，因此<font color = #FF0000>预取</font>将来会被消耗的视频帧。该预取的视频当然存储在客户应用缓存中。

6.当网络中可用速率小于视频速率时，播放将在连续播放期和停滞播放期之间进行变动。当网络中的可用速率大于视频速率时，在初始缓存时延后，用户将享受连续的播放直到视频结束。



## 9.3 IP语音

1.端到端时延得到一个关键成分是一个分组在网络路由器中经历的变化的排队时延。由于这些可变的时延，从在源中产生分组到它在接收方收到的这段时间，对于不同的分组可能会有波动。这个现象称为<font color = #FF0000>时延抖动</font>。

2.对于VoIP应用，周期性地产生分组，接收方应该在存在随机网络时延抖动的情况下尝试提供播放语音块。这经常通过结合下面两种机制来实现：

* 为每个块预先计划一个<font color = #FF0000>时间戳</font>。发送方用每个块产生的时刻为它加上时间印记。

* 在接收方<font color = #FF0000>延迟播放</font>块。接收的音频块的播放时延必须足够长，以便大多数分组在它们的预定播放时间之前被接收到。这个播放时延可能在整个音频会话期间是固定的，或者在音频会话生命期中适应性地变化。

3.使用<font color = #FF0000>固定播放时延</font>策略，接收方试图在块产生正好q ms后播放它。因此如果一个块在时刻t打上时间戳，接收方在时刻t + q播放这个块，假设这个块在那个时间已经到达。在预定播放时间之后到达的分组将被丢弃，并被认为已经丢失。

4.在<font color = #FF0000>适应性播放时延</font>中，令

​       ti = 第i个分组的时间戳 = 该分组在发送方产生的时间

​       ri = 分组i被接收方接收的时间

​       pi = 分组i在接收方播放的时间

​       第i个分组的端到端网络时延是ri – ti。由于网络时延抖动，这个时延在不同的分组之间会发送变化。令di表设计接收到第i个分组时的平均网络时延的估计值。这个估计值根据如下的时间戳来构造：
$$
d_i = (1 - u) d_{i - 1} + u(r_i - t_i)
$$
式中u是一个固定的常数。这样di是观察到的网络时延r1 – t1, ..., ri - ti的一个平滑均值。这个估计值为最近观察到的网络时延设置了比过去一段时间观察到的网络时延有更大的权重。令vi表示于估计平均时延的平均时延绝对偏差的估计值。这个估计值也可从这些时间戳构建：
$$
v_i = (1 - u)v_{i - 1} + u|r_i - t_i - d_i|
$$
​       为每个接收的分组计算估计值di和vi，尽管它们仅能用于为任何话音突峰期的第一个分组确定播放点。

​       一旦计算完了这些估计值，接收方为分组播放应用下列的算法。如果分组i是一个话音突峰期的第一个分组，它的播放时间pi计算如下：
$$
p_i = t_i + d_i + Kv_i
$$
这里K是一个正的常数。Kvi项的目的是给将来设置足够大的播放时间，以便话音突峰期中只有一小部分到达的分组由于迟到而丢失。在一个话音突峰期中任何后续分组的播放点被计算为对于这个话音突峰期的第一个分组播放时间点的偏移。令
$$
q_i = P_i - t_i
$$


表示从话音突峰期的第一个分组产生到它播放的时间长度。如果分组j也属于这个话音突峰期，它播放的时刻是
$$
p_j = t_j + q_i
$$
5.<font color = #FF0000>丢包恢复方案</font>有<font color = #FF0000>前向纠错（Forward Error Correction, FEC）</font>与<font color = #FF0000>交织</font>。

6.<font color = #FF0000>FEC</font>的基本思想是给初始的分组流增加冗余信息。以稍微增加传输速率为代价，这些冗余信息可用用来重建一些丢失分组的近似或者准确版本。第一种机制是每发送n个块之后发送一个冗余编码的块。这个冗余块通过异或n个初始块来获得。以想和中方式，在这n + 1个分组的组中，如果任何一个分组丢失，接收方能够完全重建丢失的分组。但是如果这一组中有两个或更多分组丢失，接收方则无法重建丢失的分组。通过让组的长度n + 1比较小，当丢失不是很多时，大部分丢失分组都可以恢复。然而组的长度越小，相对增加的传输速率就越大。

​       第二个FEC机制是发送一个较低分辨率的音频流作为冗余信息。发送方可能创建一个标称的音频流和一个相应的低分辨率、低比特率的音频流。这个低比特率流被认为是冗余信息。发送方通过从流中取出第n个块并附加上第n – 1个块的冗余信息，以构建第n个分组。以这种方式，只要没有连续分组的丢失，接收方都可以通过播放和后续分组一起到达的低比特率编码来隐藏丢失。当然，低比特率块比标称块的质量要低。然而，在一个流主要是由高质量块组成、偶尔出现低质量块并且没有丢失块的情况下，其整体的音频质量良好。在这种方案中，接收方在播放前只需接收两个分组，因此增加的时延小。此外，如果低比特率编码比标称编码少得多，那么传输速率的额外增加并不大。

7.作为冗余传输的另一种替代方案，VoIP应用可以发送<font color = #FF0000>交织</font>的音频。发送方在传输之前对音频数据单元重新排序，使得最初相邻的单元在传输流中以一定距离分离开来。交织可以减轻丢包的影响。一个交织流的单个丢包导致重建流中的多个小间隙，这与在非交织流中将会导致单个大间隙形成对照。

​       交织能够明显地提高音频流可感觉到的质量。它的开销也较低。交织明显的缺点是增加了时延。这限制了它在如VoIP这样的会话式应用中的使用，然而它能够很好地处理流式存储音频。交织的一个主要优点是它不增加流的带宽要求。

8.<font color = #FF0000>差错掩盖方案</font>试图为丢失的分组产生一个与初始分组类似的替代物。因为音频信号（特别是语音）呈现出大量的短期自相似性，故该方案是可行的。这些技术适合于工作在相对小的丢包率和小分组的情况。基于接收方的恢复的最简单方式是分组重复。即用在丢失之前刚到达的分组的副本来代替丢失的分组。这种方法的计算复杂度低，并且工作得相当好。基于接收方恢复的另一种形式的内插法，它使用在丢失之前和之后的音频内插形成一个合适分组来隐藏丢失。内插法比分组重复稍微好一些，但是显然需要更高的计算强度。



## 9.4实时会话式应用的协议

1.<font color = #FF0000>实时传输协议（Real-Time Transport Protocol, RTP）</font>通常运行在UDP之上。发送端在RTP分组中封装媒体块，然后再UDP报文段中封装该分组，然后将该报文段递交给IP。接收端从UDP报文段中提取出这个RTP分组，然后从RTP分组中提取出媒体块，并将这个块传递给媒体播放器来解码和呈现。

​       发送端在每个语音数据块的前面加上一个RTP首部，这个首部包括音频编码的类型、序号和时间戳。RTP首部通常是12字节。音频块和RTP首部一起形成RTP分组。然后向UDP套接字接口发送该RTP分组。在接收端，应用程序从它的套接字接口收到该RTP分组，从RTP分组中提取出该音频块，并且使用RTP分组的额首部字段来适当地解码和播放该音频块。

2.图9-1显示了RTP首部的结构。

![RTP](.\Image\RTP.png)

<center>图9-1 RTP首部字段</center>

RTP分组中的有效载荷类型字段的长度是7比特。对于音频流，有效载荷类型字段用于指示所使用的音频编码类型。如果发送方在会话过程中决定改变编码，发送方可以通过该有效载荷类型字段来通知接收方这种变化。发送方可能要通过改变该编码来提高语音质量或者减小RTP流比特率。表9-1列出了当前RTP支持的一些音频有效载荷类型。

<center>表9-1 RTP支持的一些音频有效载荷类型</center>

| 有效载荷类型编号 | 音频格式 | 采样速率 |   速率    |
| :--------------: | :------: | :------: | :-------: |
|        0         |  PCMμ律  |   8kHz   |  64kbps   |
|        1         |   1016   |   8kHz   |  4.5kbps  |
|        3         |   GSM    |   8kHz   |  13kbps   |
|        7         |   LPC    |   8kHz   |  2.4kbps  |
|        9         |  G.722   |  16kHz   | 48~64kbps |
|        14        | MPEG音频 |  90kHz   |     –     |
|        15        |  G.728   |   8kHz   |  16kbps   |

对于一个视频流，有效载荷类型用于指示视频编码类型。发送方也可以在会话期间动态改变视频编码。表9-2列出了当前RTP支持的一些视频有效载荷类型。

<center>表9-2 RTP支持的一些视频有效载荷类型</center>

| 有效载荷类型编号 | 视频格式 | 有效载荷类型编号 | 视频格式  |
| :--------------: | :------: | :--------------: | :-------: |
|        26        | 运动JPEG |        32        | MPEG1视频 |
|        31        |  H.261   |        33        | MPEG2视频 |

其他重要的字段如下：

* 序号字段。序号字段长为16比特。每发送一个RTP分组则该序号增加1，而且接收方可以用该序号来检测丢包和恢复分组序列。

* 时间戳字段。时间戳字段长32比特。它反映了RTP数据分组中的第一个字节的采样时刻。接收方能够使用时间戳来去除网络中引入的分组时延抖动，提供接收方的同步播放。时间戳是从发送方的采样时钟中获得的。

* 同步源标识符（SSRC）。SSRC字段长为32比特。它标识了RTP流的源。通常在RTP会话中的每个流都有一个不同的SSRC。SSRC不是发送方的IP地址，而是新的流开始时源随机分配的一个数。两个流被分配相同的SSRC的概率是很小的。如果发生了，这两个源应当选择一个新的SSRC值。

3.<font color = #FF0000>会话发起协议（Session Initiation Protocol, SIP）</font>是一个开放和轻型的协议，其功能如下：

* 提供了在主叫者和被叫者之间经IP网络创建呼叫的机制。它允许主叫者通知被叫者它要开始一个呼叫。它允许参与者约定媒体编码，也允许参与者结束呼叫。

* 提供了主叫者确定被叫者的当前IP地址的机制。因为用户可能动态地分配到地址，而且因为它们可能有多个IP设备，每个都有一个不同的IP地址，所以用户不具有单一的、固定的IP地址。

* 提供二零用于呼叫管理的机制，这些机制包括在呼叫期间增加新媒体流、在呼叫期间改变编码、在呼叫期间邀请新的参与者、呼叫转移和呼叫保持等。

4.SIP的特性：

* SIP是一个带外协议，即发送和接收SIP报文使用了一个不同于发送和接收媒体数据的套接字。

* SIP报文本身是可读的ASCII，这于HTTP报文类似。

* SIP要求所有的报文都要确认，因此它能够在UDP或者TCP上运行。

5.<font color = #FF0000>SIP注册器</font>把固定的人识别标志翻译为一个动态的IP地址。



## 9.5支持多媒体的网络

1.表9-3总结了能够对多媒体应用提供网络层支持的三种宽泛的方法。

<center>表9-3 支持多媒体应用的三种网络层方法</center>

| 方法                      | 粒度                   | 保证                   | 机制                                 | 复杂性 | 当前部署 |
| ------------------------- | ---------------------- | ---------------------- | ------------------------------------ | ------ | -------- |
| 尽可能利用尽力而为的服务  | 公平处理所有流量       | 无或者软               | 应用级支持，网络级资源供给           | 最小   | 无处不在 |
| 区分服务                  | 不同类型的流量处理不同 | 无或者软               | 分组标识，监管，调度                 | 中等   | 某些     |
| 每连接服务质量（QoS）保证 | 每个源到目的地处理不同 | 一旦流被准入，软或者硬 | 分组标识，监管，调度，呼叫准入和信令 | 高     | 很少     |

* 区分服务。使用区分服务，当两类流量在一台路由器中排队时，一种类型的流量可以给定严格的优于另一种类型的流量的优先权。

* 每连接服务质量（QoS）保证。使用每连接QoS保证，每个应用的实例显式地预约端到端带宽，并因此具有确保的端到端性能。<font color = #FF0000>硬保证</font>意味着应用将必定接收到它所请求的服务质量。<font color = #FF0000>软保证</font>意味着应用将以高概率接收到它所请求的服务质量。

2.对需要提供多种类型流量机制的见解：

* <font color = #FF0000>标记分组</font>使得路由器区分属于不同类型流量的分组。

* 希望在流量类型之间的提供<font color = #FF0000>流量隔离</font>的度，以便一类流量不会收到另一类流量的负面影响。

* 当为流量类型或流之间提供隔离时，希望尽可能有效地使用资源。

3.3个重要的监管准则：

* 平均速率。网络可能希望限制一个流的分组能够发送到网络中的长期平均速率。这里一个关键的问题是监管平均速率的时间间隔。一个平均速率被限制为美妙100个分组的流要比一个每分钟6000个分组的源收到的约束更严格，即使在一个足够长的时间间隔上它们有相同的平均速率。

*  峰值速率。平均速率约束限制了一个相对长的时间内能够发送到网络中的流量，而峰值约束限制了一个较短时间内能够发送的最大分组数。

* 突发长度。网络也许还希望限制极端的时间间隔内能够发送到网络中的最大分组数。

<font color = #FF0000>漏桶机制</font>是一个能够用来表征这些监管限制的抽象。漏桶由一个能够容纳b个令牌的桶组成。令牌加进桶的过程如下。可能潜在地加入桶中的新令牌总是以每秒r个令牌的速率产生。当产生一个令牌时，如果桶填充得少于b个令牌，新产生的令牌加入到该桶中；否则忽略该新产生的令牌，令牌桶保持具有b个令牌的满状态。假设在一个分组流向网络传输之前，必须首先从令牌桶中去除一个令牌。。如果令牌桶是空的，分组必须等待一个令牌。因为在桶中最多能由b个令牌，所以漏桶监管的流的最大突发长度是b个分组。此外，因为令牌产生的速率是r，所以在任何长度为t的时间间隔内能够进入网络中的最大分组数目为rt + b。因此，令牌产生速率r用于限制分组能够进入网络的长期平均速率。

4.在加权公平排队（WFQ）规则中，每个流i保证收到至少等于R ∙ wi / (∑wj)的共享链路带宽，其中R是以分组/秒为单位的链路传输速率。当将漏桶机制于WFQ结合时，假设流i的令牌桶最初是满的。然后b个分组的突发到达流i的漏桶监管器。这些分组取出了漏桶中的所有令牌，然后加入了流i的WFQ等待区域。因为这b个分组以至少R ∙ wi / (∑wj)分组/秒的速度得到服务，直到这些分组的最后一个传输完成，所以将由最大时延dmax，其中
$$
d_{max} = \frac{b_i}{R \cdot \frac {W_i}{\sum w_j}}
$$
5.因特网<font color = #FF0000>区分服务</font>（Diffserv）体系结构提供服务区分，也就是在因特网中以一种可扩展性方式用不同的方法处理不同类型流量的能力。区分服务体系结构由两个功能元素的集合所组成：

* 边界功能：分组分类和流量调节。在网络的入边缘，到达的分组被标记。更具体地说，在IPv4或者IPv6分组首部中的区分服务（DS）字段被设置为某个值。分组得到的标记标识了该分组所属的流量类型。然后不同类型的流量将在核心网络得到不同的服务。

* 核心功能：转发。当一个DS标记的分组到达一个Diffserv使能的服务器时，根据与分组类型相关的所谓的<font color = #FF0000>每跳行为（Per-Hop Behavior, PHB）</font>，该分组被转发到它的下一跳。每跳行为影响在竞争的流量类型之间共享路由器缓存和链路带宽的方式。Diffserv体系结构的一个关键原则是路由器的每跳行为只基于分组标记，即分组所属的流量类型。

6.已经定义了两种PHB：<font color = #FF0000>加速转发（Expedited Forwarding, EF）</font>PHB规定了一类流量离开路由器的速率必须等于或者大于某个已配置的速率。<font color = #FF0000>确保转发（Assured Forwarding, AF）</font>PHB将流量分为4类，其中每个AF类都确保提供某种最小数量的带宽和缓存。

7.让流申告它的QoS需求，然后让网络接收该流或者阻塞该流的过程称为<font color = #FF0000>呼叫准入</font>过程。如果不总是能够提供充分的资源，并且要确保QoS，则需要一个呼叫准入过程，在这个过程中流申告其QoS需求，然后要么被网络准入，要么被网络阻塞。